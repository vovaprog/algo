625a

в питоне деление целых дает float результат, нужно использовать целочисленное деление //
иногда быстрее написать тупой цикл, чем придумывать формулу.
вместо вычисления значения в одном большом выражении нужно разбить вычисление на вычисление нескольких значений. 


590c
При переборе нужно использовать объект количество которых меньше,
т.е. в этой задаче лучше смотреть расстояния от каждой страны, а не от каждой клетки до всех стран.

иногда проще считать сразу все данные и работать с массивом.

иногда лучше работать с графом как в 2-мерным массивом, а не преобразовывать индексы.


522d (пары в строке vk)

Все запросы даны в начале задачи.
Можно искать ответ на все запросы одновременно.
Дерево отрезков, дерево фенвика.

codefest16b
не обязательно искать формулу.
можно просто пройти все значения пока не будет найдено (или не найдено) нужное.


605a
максимальная возрастающая подпоследовательность
внимательно читать условие - может быть ограничение на входные данные, которое поможет.

631b
принтер красит массив.
Не нужно выполнять запросы. Можно сразу понять цвет, зная последний запрос.


631d
поиск  Кнута — Морриса — Пратта

644c
hash string and set
Чтобы узнать хеш массива его нужно отсортировать, все элементы объединить в строку через разделитель и взять хеш строки.


http://codeforces.com/blog/entry/6251?locale=ru
The problem is the output, cout << endl flushes the output every time wich hit performance badly. To output an end line without flushing just use #define endl '\n'
favor '\n' instead of endl for ending lines. endl flushes the buffer every time. 
Put this: ios_base::sync_with_stdio(false);cin.tie(0); in the beggining of the main func. cin/cout will be as fast as scanf and printf (even faster). BUT DONT USE ENDL (use "\n")
try this problem http://codeforces.com/contest/456/problem/E just copy any accepted C++ solution and submit it with endl and ios_base::sync_with_stdio(false);cin.tie(0); it will fail.
inline void scan_uint(int* p) {
    static char c;
    while ((c = getchar_unlocked()) < '0'); // just to be safe
    for (*p = c-'0'; (c = getchar_unlocked()) >= '0'; *p = *p*10+c-'0');
}

int64
scanf("%I64d",&x);
printf("%I64d",x);

float
scanf("%f",&x);
printf("%f",x);

double
scanf("%lf",&x);
printf("%lf",x);

long double
scanf("%llf",&x);
printf("%llf",x);

cin.tie(0);

Мой тест (test_stdio.cpp):
без std::ios::sync_with_stdio(false); cin.tie(0);   cin в 4 раза медленнее чем scanf на int и на строках.
c std::ios::sync_with_stdio(false); cin.tie(0); cin и scanf примерно одинаково.

//===================================================================

Можно сортировать сразу по нескольким ключам и таким образом один массив разбить
на группы, а внутри группы отсортировать по заданному значению.
codeforces 17040715
struct Node{
    char s[12];int id,val;
    bool operator < (const Node &z)const{
        return id != z.id?id < z.id:val > z.val;
    }
}ns[100005];
sort(ns,ns+n);


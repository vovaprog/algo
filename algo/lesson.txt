625a

в питоне деление целых дает float результат, нужно использовать целочисленное деление //
иногда быстрее написать тупой цикл, чем придумывать формулу.
вместо вычисления значения в одном большом выражении нужно разбить вычисление на вычисление нескольких значений. 


590c
При переборе нужно использовать объект количество которых меньше,
т.е. в этой задаче лучше смотреть расстояния от каждой страны, а не от каждой клетки до всех стран.

иногда проще считать сразу все данные и работать с массивом.

иногда лучше работать с графом как в 2-мерным массивом, а не преобразовывать индексы.


522d (пары в строке vk)

Все запросы даны в начале задачи.
Можно искать ответ на все запросы одновременно.
Дерево отрезков, дерево фенвика.

codefest16b
не обязательно искать формулу.
можно просто пройти все значения пока не будет найдено (или не найдено) нужное.


605a
максимальная возрастающая подпоследовательность
внимательно читать условие - может быть ограничение на входные данные, которое поможет.

631b
принтер красит массив.
Не нужно выполнять запросы. Можно сразу понять цвет, зная последний запрос.


631d
поиск  Кнута — Морриса — Пратта

644c
hash string and set
Чтобы узнать хеш массива его нужно отсортировать, все элементы объединить в строку через разделитель и взять хеш строки.


http://codeforces.com/blog/entry/6251?locale=ru
The problem is the output, cout << endl flushes the output every time wich hit performance badly. To output an end line without flushing just use #define endl '\n'
favor '\n' instead of endl for ending lines. endl flushes the buffer every time. 
Put this: ios_base::sync_with_stdio(false);cin.tie(0); in the beggining of the main func. cin/cout will be as fast as scanf and printf (even faster). BUT DONT USE ENDL (use "\n")
try this problem http://codeforces.com/contest/456/problem/E just copy any accepted C++ solution and submit it with endl and ios_base::sync_with_stdio(false);cin.tie(0); it will fail.
inline void scan_uint(int* p) {
    static char c;
    while ((c = getchar_unlocked()) < '0'); // just to be safe
    for (*p = c-'0'; (c = getchar_unlocked()) >= '0'; *p = *p*10+c-'0');
}

int64
scanf("%I64d",&x);
printf("%I64d",x);

float
scanf("%f",&x);
printf("%f",x);

double
scanf("%lf",&x);
printf("%lf",x);

long double
scanf("%llf",&x);
printf("%llf",x);

cin.tie(0);

Мой тест (test_stdio.cpp):
без std::ios::sync_with_stdio(false); cin.tie(0);   cin в 4 раза медленнее чем scanf на int и на строках.
c std::ios::sync_with_stdio(false); cin.tie(0); cin и scanf примерно одинаково.

//===================================================================

Можно сортировать сразу по нескольким ключам и таким образом один массив разбить
на группы, а внутри группы отсортировать по заданному значению.
codeforces 17040715
struct Node{
    char s[12];int id,val;
    bool operator < (const Node &z)const{
        return id != z.id?id < z.id:val > z.val;
    }
}ns[100005];
sort(ns,ns+n);


652d_5
Быстрое нахождение индекса элемента в set - нужно использовать 
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<int,null_type,greater<int>,rb_tree_tag,tree_order_statistics_node_update> Tree;
Tree begs;
s.count = begs.order_of_key(s.b);
begs.insert(s.b);

652d_6
Чтобы использовать большие или отрицательные значения в дереве Фенвика можно создать массив со значениями,
а в дереве использовать индексы в массиве.


chef_bintreeq_2
Если в задаче есть функция и она возрастающая или убывающая, то на ней можно использовать бинарный поиск.

669c (с соревнования)
оценить ограничения параметров - возможно, задача решается просто перебором.
Если не найдено умное решение для задачи за нужное время - попробовать отослать
тупое решение.
Вместо того, чтобы проделывать команды над всей матрицей можно выполнить 
последовательность команд для каждого известного значения.


667c3.cpp (с соревнования)
Можно написать тупую рекурсию - полный перебор и в ней проверять,
был ли уже вызов с такими параметрами и если был, то не вызывать рекурсию.
(параметры хранить в set)

675d_2
В соревновании внимательно выбирать, какую задачу решать.
Возможно, ставить таймер - если нет идей - пробовать другую.
В этом соревновании задача D была намного легче, чем C.
Если строится дерево по определенному правилу, то чтобы понять положение элемента в нем
не нужно его строить. Элемент может занимать определенное место среди уже добавленных элементов.

675b
100_000 * 100_000 - не влезает в int! Нужно использовать int64.

